{"version":3,"sources":["STDIN"],"sourcesContent":["/****************************************************************************\r\n * JState by Matt Tropiano (C) 2022\r\n * Requires ECMAScript 6\r\n * Licensed for use under the MIT License\r\n * @license\r\n ****************************************************************************/\r\n (function(CTX){\r\n\t\r\n    /********************************************************************/\r\n    /** Test Browser Capabilities                                      **/\r\n    /********************************************************************/\r\n\r\n    if (!CTX.document.querySelectorAll) {\r\n        console.error(\"Missing required function: document.querySelectorAll.\");\r\n        return;\r\n    }\r\n    if (!CTX.document.querySelector) {\r\n        console.error(\"Missing required function: document.querySelector.\");\r\n        return;\r\n    }\r\n    if (!CTX.Element.prototype.querySelectorAll) {\r\n        console.error(\"Missing required function: Element.querySelectorAll.\");\r\n        return;\r\n    }\r\n    if (!CTX.Element.prototype.querySelector) {\r\n        console.error(\"Missing required function: Element.querySelector.\");\r\n        return;\r\n    }\r\n\r\n\r\n    /********************************************************************/\r\n    /** Utilities                                                      **/\r\n    /********************************************************************/\r\n\r\n    const isType = function(obj, type) {\r\n        return Object.prototype.toString.call(obj) === '[object '+type+']';\r\n    };\r\n\r\n    const isUndefined = function(obj) {\r\n        return (typeof obj) === 'undefined';\r\n    };\r\n\r\n    const isNull = function(obj) {\r\n        return obj === null;\r\n    };\r\n\r\n    const isBoolean = function(obj) {\r\n        return isType(obj, 'Boolean');\r\n    };\r\n\r\n    const isNumber = function(obj) {\r\n        return isType(obj, 'Number');\r\n    };\r\n\r\n    const isString = function(obj) {\r\n        return isType(obj, 'String');\r\n    };\r\n\r\n    const isArray = function(obj) {\r\n        return isType(obj, 'Array');\r\n    };\r\n\r\n    const isFunction = function(obj) {\r\n        return isType(obj, 'Function');\r\n    };\r\n\r\n    const isObject = function(obj) {\r\n        return isType(obj, 'Object');\r\n    };\r\n\r\n    const isBlank = function(obj) {\r\n        return (\r\n                isUndefined(obj)\r\n            || isNull(obj) \r\n            || (isArray(obj) && obj.length === 0) \r\n            || (isNumber(obj) && isNaN(obj)) \r\n            || (isString(obj) && obj.trim().length === 0)\r\n            || obj === 0 \r\n        );\r\n    };\r\n    \r\n    const each = function(list, func) {\r\n        if (isUndefined(list) || isNull(list)) {\r\n            return;\r\n        }\r\n        else if (isBoolean(list) || isNumber(list) || isString(list)) {\r\n            func(list, null, 1);\r\n        }\r\n        else {\r\n            for (let x in list) if (list.hasOwnProperty(x)) {\r\n                if (func(list[x], x, list.length))\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n\r\n    // Matches() polyfill.\r\n    const elemMatches = (\r\n        Element.prototype.matches ||\r\n        Element.prototype.matchesSelector || \r\n        Element.prototype.msMatchesSelector\r\n    );\r\n    \r\n    const matches = function(elem, selector){\r\n        return elemMatches.call(elem, selector);\r\n    };\r\n\r\n    /********************************************************************/\r\n    /** Classes                                                        **/\r\n    /********************************************************************/\r\n\r\n    // Private state applier timeout setup.\r\n    // Must be apply()'ed to set \"this\" as the calling AppState object.\r\n    const _STATETIMEOUTAPPLY = function() {\r\n        if (!(this instanceof AppState))\r\n            return;\r\n\r\n        if (this.applierTimeout != null) {\r\n            clearTimeout(this.applierTimeout);\r\n            this.applierTimeout = null;\r\n        }\r\n\r\n        this.applierTimeout = setTimeout(() => {\r\n            each(this.nextStateChanges, (value, key) => {\r\n                if (this.stateApplierFunctionMap[key]) {\r\n                    this.stateApplierFunctionMap[key](value, this.state[key]);\r\n                    this.state[key] = value;\r\n                }\r\n            });\r\n            this.nextStateChanges = {};\r\n        }, 0);\r\n    };\r\n\r\n    // Event name converter.\r\n    const _EVENTNAME = (name) => ('on' + name.toLowerCase());\r\n\r\n    // Event attacher function.\r\n    const _ATTACH = (eventName, eventfunc) => ((element) => {element[eventName] = eventfunc;});\r\n\r\n    /********************************************************************/\r\n\r\n    /**\r\n     * AppState class - main driver for state listening.\r\n     */\r\n    class AppState {\r\n\r\n        /**\r\n         * Creates the app state with a function map.\r\n         * @param {Object} funcMap the mapping of state member to handler function.\r\n         * @see addHandler\r\n         */\r\n        constructor(funcMap) {\r\n\r\n            if (!isObject(funcMap)) {\r\n                throw new Error(\"Expected object for state applier.\");\r\n            }\r\n\r\n            // Handler functions.\r\n            this.stateApplierFunctionMap = {};\r\n            this.changeVerifierMap = {};\r\n\r\n            // State and state processing.\r\n            this.state = {};\r\n            this.nextStateChanges = {};\r\n            this.applierTimeout = null;\r\n\r\n            // Main bread and butter.\r\n            each(funcMap, (f, n) => {\r\n                this.addHandler(n, f);\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Adds a state handler to this class.\r\n         * @param {string} name the state member name to bind to.\r\n         * @param {Function} func the handler function.\r\n         * @returns {AppState} this AppState object.\r\n         */\r\n        addHandler(name, func) {\r\n            if (isFunction(func)) {\r\n                this.stateApplierFunctionMap[name] = func;\r\n            }\r\n            else if (isNull(func) || isUndefined(func)) {\r\n                this.removeHandler(name);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Removes a state handler from this class.\r\n         * @param {string} name the state member name to bind to.\r\n         * @returns {AppState} this AppState object.\r\n         */\r\n        removeHandler(name) {\r\n            delete this.stateApplierFunctionMap[name];\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Sets one or more fields on the state, but doesn't attempt to apply\r\n         * to the state functions.\r\n         * This will merge the incoming object into the current state.\r\n         * @param {Object} nextState the new state changes.\r\n         * @returns {AppState} this AppState object.\r\n         */\r\n        setState(nextState) {\r\n            if (!isObject(nextState)) {\r\n                return;\r\n            }\r\n            each(nextState, (value, key) => {\r\n                this.state[key] = value;\r\n            });\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Applies a state object to this state manager.\r\n         * This will merge the incoming object into the current state, and\r\n         * send the changed contents to the state applier function map for applying.\r\n         * \r\n         * This function can be called many times in one event - all accumulated changes\r\n         * get applied once this event yields.\r\n         * @param {Object} nextState the new state changes.\r\n         * @returns {AppState} this AppState object.\r\n         */\r\n        applyState(nextState) {\r\n            if (!isObject(nextState)) {\r\n                return;\r\n            }\r\n            each(nextState, (value, key) => {\r\n                if (this.state[key] !== value) {\r\n                    this.nextStateChanges[key] = value;\r\n                }\r\n            });\r\n            \r\n            // Apply after event yield - many calls during this event may accumulate changes.\r\n            _STATETIMEOUTAPPLY.apply(this);\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Forces a refresh on a state member as though it changed.\r\n         * Useful for \"deep\" changes on state members like objects and arrays that\r\n         * may not be detected at the member level or did not qualify via verification.\r\n         * \r\n         * This function can be called many times in one event - all accumulated changes\r\n         * get applied once this event yields.\r\n         * @param {String...} arguments a series of member names.\r\n         * @returns {AppState} this AppState object.\r\n         */\r\n        touchState(/* memberName... */) {\r\n            each(arguments, (memberName) => {\r\n                if (this.stateApplierFunctionMap[memberName]) {\r\n                    this.nextStateChanges[memberName] = this.state[memberName];\r\n                }\r\n            });\r\n            \r\n            // Apply after event yield - many calls during this event may accumulate changes.\r\n            _STATETIMEOUTAPPLY.apply(this);\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Binds an event handler to a state applier.\r\n         * This just facilitates some shorthanding.\r\n         * @param {string} eventName the element event name (e.g. \"click\", \"mouseover\", etc.).\r\n         * @param {*} selection If String, use this as a selector for elements. Else if Array of elements, the elements to bind to.\r\n         * @param {Object} nextState if function, the function must return an object to pass to applyState. First parameter is event object, Second is the current state object.\r\n         * \t\tIf object, it is the object to directly pass to applyState.\r\n         * @returns {AppState} this AppState object.\r\n         */\r\n        bindStateEvent(eventName, selection, nextState) {\r\n            const self = this;\r\n            \r\n            eventName = _EVENTNAME(eventName);\r\n\r\n            const group = isString(selection)\r\n                ? document.querySelectorAll(selection)\r\n                : selection;\r\n\r\n            each(group, _ATTACH(eventName, function(event) {\r\n                if (isFunction(nextState)) {\r\n                    self.applyState(nextState(event, self.state));\r\n                } else {\r\n                    self.applyState(nextState);\r\n                }\r\n            }));\r\n            return this;\r\n        }\r\n    }\r\n\r\n    /********************************************************************/\r\n\r\n    const JState = new function(){};\r\n\r\n    /**\r\n     * Creates a new application state driver.\r\n     * @param {Object} stateApplicationFuncMap a map of state member name to Function.\r\n     * \t\tThe function is called if that state's member changes its value.\r\n     * \t\tFirst function parameter is the new value.\r\n     * \t\tSecond function parameter is the previous value.\r\n     * @returns a new AppState object.\r\n     */\r\n    JState.createAppState = function(stateFuncMap) {\r\n        return new AppState(stateFuncMap);\r\n    };\r\n\r\n    /**\r\n     * Creates a state object that reflects the input from changes to a form.\r\n     * @param {Element} formElement the Form element to bind.\r\n     * @param {object} targetObject (OPTIONAL) the object reference to bind to. If blank, a new object is returned.\r\n     * @returns the object reference that will contain the object state.\r\n     */\r\n    JState.bindFormState = function(formElement, targetObject) {\r\n        \r\n        if (isBlank(formElement)) {\r\n            return;\r\n        }\r\n\r\n        const state = targetObject || {};\r\n\r\n        const CHECKBOXCHANGE = _ATTACH('onchange', (event) => {\r\n            const element = event.srcElement;\r\n            const memberName = element.getAttribute('name');\r\n            if (element.selected) {\r\n                state[memberName] = element.value;\r\n            }\r\n            else {\r\n                delete state[memberName];\r\n            }\r\n        });\r\n\r\n        const TEXTCHANGE = _ATTACH('onchange', (event) => {\r\n            const element = event.srcElement;\r\n            const memberName = element.getAttribute('name');\r\n            state[memberName] = element.value;\r\n        });\r\n\r\n        const SELECTCHANGE = _ATTACH('onchange', (event) => {\r\n            const element = event.srcElement;\r\n            const memberName = element.getAttribute('name');\r\n            const multi = !!element.getAttribute('multiple');\r\n\r\n            if (multi) {\r\n                state[memberName] = [ ...element.options ].filter((option) => option.selected).map((option) => option.value);\r\n            }\r\n            else {\r\n                state[memberName] = element.value;\r\n            }\r\n        });\r\n\r\n        formElement.querySelectorAll('input[type=\"checkbox\"], input[type=\"radio\"]')\r\n            .forEach(CHECKBOXCHANGE);\r\n        formElement.querySelectorAll(':not(input[type]), :not(input[type=\"checkbox\"], input[type=\"radio\"], input[type=\"button\"], input[type=\"submit\"]), textarea')\r\n            .forEach(TEXTCHANGE);\r\n        formElement.querySelectorAll('select')\r\n            .forEach(SELECTCHANGE);\r\n\r\n        return state;\r\n    };\r\n\r\n    /********************************************************************/\r\n\r\n    let old$JSAssignment     = CTX.$JS;\r\n\r\n    /**\r\n     * Restores the previous assigment of '$JS' at load.\r\n     */\r\n    JState.noConflict = function() {\r\n        CTX.$JS     = old$JSAssignment;\r\n    };\r\n    \r\n    CTX.JState = JState;\r\n    CTX.$JS    = JState;\r\n\r\n})(this);\r\n"],"names":["CTX","document","querySelectorAll","console","error","querySelector","Element","prototype","isUndefined","obj","isNull","isNumber","isType","isString","isFunction","isObject","isBlank","length","isNaN","trim","each","list","func","let","x","hasOwnProperty","type","Object","toString","call","matches","matchesSelector","msMatchesSelector","_STATETIMEOUTAPPLY","this","AppState","applierTimeout","clearTimeout","setTimeout","nextStateChanges","value","key","stateApplierFunctionMap","state","_ATTACH","eventName","eventfunc","element","constructor","funcMap","Error","changeVerifierMap","f","n","addHandler","name","removeHandler","setState","nextState","applyState","apply","touchState","arguments","memberName","bindStateEvent","selection","self","toLowerCase","group","event","JState","createAppState","stateFuncMap","bindFormState","formElement","targetObject","CHECKBOXCHANGE","srcElement","getAttribute","selected","TEXTCHANGE","SELECTCHANGE","multi","options","filter","option","map","forEach","old$JSAssignment","$JS","noConflict"],"mappings":"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"}